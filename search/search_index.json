{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p><code>go-dito</code> is another HTTP mock server similar to Microcks and other API simulators. The primary target of it is to mock/stub HTTP APIs for testing purposes.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>OpenAPI support (v2 &amp; v3)</li> <li>plain HTTP server</li> <li>GraphQL support (coming soon)</li> </ul>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>go-dito serve</code> - Start the live-reloading docs server.</li> </ul>"},{"location":"getting_started/","title":"Installation","text":""},{"location":"configuration/basics/","title":"Configuration","text":"<p><code>go-dito</code> can be configured via a configuration file in PKL format. The schema of the configuration can be found in the AppConfig.pkl</p> <p>To override the default configuration you have to <code>amend</code> the configuration file:</p> <pre><code>amends \"https://raw.githubusercontent.com/prskr/go-dito/refs/heads/main/assets/AppConfig.pkl\"\n\nserver {\n  port = 8080\n}\n</code></pre> <p>The <code>amends</code> statement is used to include the default configuration and override it with your own configuration. In the example above it is using the latest version of the main branch, as soon as there are releases you should use the release tag instead of the branch name.</p> <p>The advantage of PKL is, that the configuration has a schema and you can get autocompletion and validation in your editor.</p>"},{"location":"configuration/basics/#domains","title":"Domains","text":"<p><code>domains</code> is the central configuration section where you can configure multiple domains with different behaviors. It is only possible to use one kind of behavior per domain. This means, it is not possible to mix for instance OpenAPI and GraphQL on a single domain. This might change in the future if necesssary but for now this keeps the complexity both in the configuration and in the implementation at bay.</p>"},{"location":"configuration/basics/#server","title":"Server","text":"<p>The <code>server</code> section is where listening host and port are configured. Furthermore there are some fine grained configuration options for the HTTP server such as <code>readHeaderTimeout</code>.</p>"},{"location":"configuration/basics/#telemetry","title":"Telemetry","text":"<p>The <code>telemetry</code> section is where things like logging is configured and also OpenTelemetry (OTeL) related settings will be located in this section.</p>"},{"location":"configuration/plain_http/","title":"Plain HTTP configuration","text":"<p>As already mentioned, the plain HTTP server configuration is the easiest way to get started. To set up a simple HTTP server stub, you can start with the following configuration:</p> <pre><code>amends \"https://raw.githubusercontent.com/prskr/go-dito/refs/heads/main/assets/AppConfig.pkl\"\n\ndomains {\n    [\"localhost:3498\"] = new PlainRuleSpec {\n      rules = Set(\n        #\"http.Method(\"GET\") -&gt; http.Path(\"/api/v1/account/42\") =&gt; File(\"testdata/sample.json\", \"application/json\")\"#,\n        #\"http.Method(\"POST\") -&gt; http.Path(\"/api/v1/account/42/withdraw\") =&gt; Json(`{\"name\":\"Ted.Tester\"}`)\"#\n      )\n    }\n}\n</code></pre> <p>In the above snippet are two rules configured:</p> <ol> <li>Respond to <code>GET /api/v1/account/42</code> with a file located at <code>testdata/sample.json</code> and set the content type header to <code>application/json</code>.</li> <li>Respond to <code>POST /api/v1/account/42/withdraw</code> with a JSON body <code>{\"name\":\"Ted.Tester\"}</code> - this also sets the content type to <code>application/json</code></li> </ol> <p>For further details on the DSL see matchers and handlers</p>"},{"location":"dsl/handlers/","title":"Request handler","text":"<p>Request handlers are used in the plain HTTP server and will also be used in the GraphQL configuration. Handlers are basically function calls that are modifying the HTTP response. Similar to many programming languages, handlers can be polymorph, i.e. there are possibly multiple overload of the same hander.</p>"},{"location":"dsl/handlers/#json-handler","title":"JSON handler","text":"<p>The <code>json(...)</code> handler is intended for small inline JSON responses. It validates whether the passed string is a proper JSON string, writes the string to the response body and sets the <code>Content-Type</code> header to <code>application/json</code>.</p> <p>There are multiple overloads:</p> <ol> <li><code>json(jsonResponse string)</code></li> <li><code>json(statusCode int, jsonResponse string)</code></li> </ol> <p>In case there's no explicit status code given, dito will fallback to HTTP OK (200).</p>"},{"location":"dsl/handlers/#file-handler","title":"File handler","text":"<p>The <code>file(...)</code> handler is more generic than the <code>json(...)</code> handler because it reads arbitrary files from the file system to the HTTP response.</p> <p>The following overloads are available:</p> <ol> <li><code>file(filePath string)</code></li> <li><code>file(filePath string, contentType string)</code></li> <li><code>file(statusCode int, filePath string, contentType string)</code></li> </ol> <p>In case there's no explicit status code given, dito will fallback to HTTP OK (200). If no content type is specified <code>go-dito</code> will try to infer the content type based on some heuristics of the Go standard library.</p>"},{"location":"dsl/intro/","title":"DSL introduction","text":"<p><code>go-dito</code> comes with a custom DSL to configure routing rules in a very simple yet powerful way.</p> <p>Generally, the DSL itself - meaning names of matchers &amp; providers are not case sensitive. So when writing rules you can use <code>http.method(\"GET\")</code> as well as <code>HTTP.Method(\"GET\")</code> or <code>HTTP.method(\"GET\")</code>.</p> <p>\"Arguments\" of \"functions\" in the DSL are potentially case sensitive depending on the individual use case.</p>"},{"location":"dsl/matchers/","title":"Request matchers","text":"<p>Request matchers are used in basically every kind of server configuration. They are matching against properties of an incoming HTTP request and are helping <code>go-dito</code> to distinguish between multiple handlers.</p> <p>Matchers can be 'chained' to build sophisticated routing rules.</p> <p>Similar to many programming languages, matchers can be polymorph, i.e. there are possibly multiple overload of the same matcher.</p>"},{"location":"dsl/matchers/#http-method","title":"HTTP method","text":"<p>The <code>http.method(methodName string)</code> matcher - as the name already suggests - matches on the HTTP method. It's a good start for a matcher chain because it's very cheap and can be used to filter out requests early.</p>"},{"location":"dsl/matchers/#http-path","title":"HTTP path","text":"<p>The <code>http.path(path string)</code> matcher matches on the request path. It is an exact match, so it's not possible to use wildcards or regex here. It is also case sensitive. For this reason this matcher is also a lot cheaper than for instance HTTP path pattern and should therefore be preferred if possible.</p>"},{"location":"dsl/matchers/#http-path-pattern","title":"HTTP path pattern","text":"<p>The <code>http.pathPattern(pattern string)</code> matcher is a more sophisticated version of the HTTP path matcher. It allows to use regex patterns to match on the request path. The pattern is compiled to a regex and matched against the request path. The underlying regex engine is the Go standard library regex engine.</p>"},{"location":"dsl/matchers/#http-header","title":"HTTP header","text":"<p>The <code>http.header(key string, value string)</code> matcher matches on a specific header key and value. It is also an exact match, so it's not possible to use wildcards or regex here. For this reason this matcher is also considered a cheap matcher and can should be rather early in the matcher chain.</p>"},{"location":"dsl/matchers/#http-header-present","title":"HTTP header present","text":"<p>The <code>http.headerPresent(key string)</code> matcher is an easier variant of HTTP header. It only matches whether a certain header is present, but it does not check the value of the header at all.</p>"},{"location":"dsl/matchers/#http-query","title":"HTTP query","text":"<p>The <code>http.query(key string, value string)</code> matcher checks whether a certain combination of query key and value are set for an incoming HTTP request. The matcher is both exact and case sensitive. A more generic alternative is HTTP query pattern but due to the fact that it is based on regex patterns, it is also less performant.</p>"},{"location":"dsl/matchers/#http-query-pattern","title":"HTTP query pattern","text":"<p>The <code>http.queryPattern(key string, pattern string)</code> matcher is similar to the aforementioned HTTP query matcher but uses a regex pattern instead of an exact string to match the query value.</p>"},{"location":"features/graphql/","title":"GraphQL","text":"<p>coming soon</p>"},{"location":"features/openapi/","title":"OpenAPI","text":"<p>When already working with OpenAPI (or TypeSpec) you can use the schema to configure the mock server. The server will generate the responses either based on the examples provided in the schema or the response schema.</p> <p>If desired, you can also provide multiple examples and configure rules when to return which example. To keep the schema readable and compatible with other tools, <code>dito</code> uses specification extensions to add conditions to your examples.</p> <p>A simple example would be:</p> <pre><code># ...\nresponses:\n  \"200\":\n    description: Successful operation\n    content:\n      application/json:\n        schema:\n          $ref: \"#/components/schemas/Pet\"\n        examples:\n          ted:\n            value: |\n              {\"id\":12, \"name\": \"ted\"}\n            x-dito/when: 'http.JsonPath(\"$.name\", \"doggie\")'\n# ...\n</code></pre> <p>The conditions are expressed in a simple domain specific language (DSL) that allows you to match against various request properties.</p> <p>Besides of the response body generation, <code>go-dito</code> also validates request and response against the schema and returns an error if the request or response doesn't match the schema. This guarantees that the mock server behaves like the real API.</p>"},{"location":"features/plain_http/","title":"Plain HTTP server","text":"<p>The plain HTTP server uses the same DSL as in the OpenAPI support to match against requests and extends it with the possibility to configure a response behavior. It's the simplest way to configure a mock server and is perfect for small APIs or to get started quickly.</p> <p>The downside is that the <code>go-dito</code> configuration is disconnected from your API schema and you have to maintain the configuration separately. Also it doesn't support validation of the request/response bodies. This might change in the future - at least for the request body - but it would require a user provided schema definition for the request body.</p>"}]}